% Created 2019-05-13 lun. 17:54
% Intended LaTeX compiler: pdflatex
\documentclass[12pt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\renewcommand*\oldstylenums[1]{{\fontfamily{fxlj}\selectfont #1}}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{lmodern}
\usepackage[french]{babel}
\usepackage{listings}
\usepackage[margin=1in]{geometry}
\author{Maxime Huyghe}
\date{Labyrinthe}
\title{Rapport de projet tutoré}
\hypersetup{
 pdfauthor={Maxime Huyghe},
 pdftitle={Rapport de projet tutoré},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.1 (Org mode 9.2.3)},
 pdflang={French}}
\begin{document}

\maketitle
\tableofcontents

\clearpage
\section{Introduction}
\label{sec:org579aa60}
Ce projet avait pour but la réalisation d'un simulateur de labyrinthe avec solveur en Java.

\section{Fonctionnalités}
\label{sec:orgc6150f9}
\subsection{Navigation}
\label{sec:org41aada4}
La navigation se fait automatiquement après qu'un choix ai été fait et il est possible de revenir en
arrière à l'aide de la « barre de navigation » en haut.
\begin{center}
\includegraphics[width=.9\linewidth]{img/0choosegrid.png}
\end{center}
\subsection{Choix de la grille}
\label{sec:org265d678}
On pourra, au choix, soit créer une grille :
\begin{center}
\includegraphics[width=.9\linewidth]{img/2GridMaker.png}
\end{center}
Soit en charger une depuis un fichier à l'aide d'un JFileChooser :
\begin{center}
\includegraphics[width=.9\linewidth]{img/1JFileChooser.png}
\end{center}
\subsection{Choix de l'algorithme}
\label{sec:orgf23b911}
On doit ensuite choisir un algorithme de résolution :
\begin{center}
\includegraphics[width=.9\linewidth]{img/3choosealgorithm.png}
\end{center}
\subsection{Choix du mode de résolution}
\label{sec:org4d3915e}
Après avoir passé le menu correspondant, on peut ensuite lancer :
\begin{itemize}
\item soit une visualisation manuelle que l'on fera avancer en appuyant sur une touche du clavier
\begin{center}
\includegraphics[width=.9\linewidth]{img/4manual.png}
\end{center}
\item soit faire fonctionner l'algorithme automatiquement, suite à quoi une popup nous informera du résultat
\begin{center}
\includegraphics[width=.9\linewidth]{img/5auto.png}
\end{center}
\end{itemize}
\subsection{Attention!}
\label{sec:org9950a8e}
Les utilisateurs trop pressés qui essaieront de sauter des étapes auront droit à une popup les rappelant à l'ordre :
\begin{center}
\includegraphics[width=.9\linewidth]{img/6error.png}
\end{center}

\section{Organisation et fonctionnement général}
\label{sec:org343513b}
Tous les attributs ont un \texttt{\_} au début de leur nom, il est ainsi aisé de les reconnaitre sans \texttt{this}.

La fonction \texttt{main} de \texttt{Main.java} se contente d'initialiser un \texttt{Controller}, qui fera le reste du travail.
Ce \texttt{Controller} va donc appeler les méthodes de sa \texttt{View} pour que l'affichage reflète son état/ce dont il a besoin,
dans des méthodes telles que \texttt{chooseGridCreationMethod} ou \texttt{chooseMovementAlgorithm}.
Les \texttt{Listener} qui auront été passé à View vont ensuite appeler une méthode de \texttt{Controller}, comme \texttt{createGrid},
\texttt{chooseGridFromFile} etc, qui relanceront ensuite ce processus soit directement soit par un autre appel.
Ainsi, on a une séparation entre Model-Contrôleur et Vue, et dans une moindre mesure entre Model et Contrôleur
(\texttt{Grid} séparée);

\section{Diagramme de classes}
\label{sec:orgc0bfc26}
Quelques différences avec le code, notament dans \texttt{DeterministicAlgorithm}.
Pour voir en plus gros: img/7UML.png
\begin{center}
\includegraphics[width=.9\linewidth]{img/7UML.png}
\end{center}

\section{Algorithme}
\label{sec:org63c12d3}
Mon algorithme se base sur le principe de la recherche en profondeur, mais il n'est malheureusement pas fonctionnel pour toutes les grilles possibles.
Son fonctionnement:
\begin{itemize}
\item L'algorithme est arrêté si la direction du dernier mouvement n'est pas déterminée (il faudrait faire autre chose à la place de ces directions invalides pour rendre l'algorithme fonctionnel)
\item Le personnage essaie de bouger dans la direction \_currentDirection (SOUTH au début)
\item Sa position actuelle est mise sur la pile \texttt{\_visited}
\item Un prochain point possible (\texttt{candidate}) est déterminé en utilisant \texttt{\_visited} et \texttt{\_doNotGo}
\begin{itemize}
\item si il a bien bougé, la direction de son prochain mouvement est déterminée: soit le candidat, soit la valeur du haut de la pile \texttt{\_visited} si ce dernier n'existe pas
\item si il n'a pas bougé, on ajoute le point vers lequel il a essayé  de se rendre à \texttt{doNotGo} puis on fait la même chose que quand il a bougé
\item si il a atteint la sortie, on met fin à l'algorithme
\end{itemize}
\end{itemize}

\section{Conclusion}
\label{sec:orgc6a0915}
Ce projet m'a permis de découvrir la programmation événementiel objet, un contraste
très marqué avec le langage Elm, que j'ai utilisé pour un projet personnel.
Je n'ai pas vraiment apprécié, et ai trouvé l'API Swing trop complexe, mais gérer
cette complexité était néanmoins intéressant.
Je regrette cependant d'avoir procrastiné (algorithme).
\end{document}